#include <stdarg.h>
#include <mex.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "matrix.h"
#include <string.h> /* memset */
#include "misc.h"
#include "vdcpd.h"

/*=========================================================
 * genVDCPDMex.c - 
 * Code for variable density complementary poisson-disc
 * sampling
 *
 * Usage:
 * M = genVDCPDMex(numMasks, alpha, feasiblePoints, pdfType, R, opt,
 *                 shapeOpt, isPeriodicInK, isPeriodicInT) 
 * 
 * numMasks       = # regions over which to distribute samples
 * FOVRatio       = anisotropy factor (FOVz / FOVy)
 * feasiblePoints = [ny nz] matrix of feasible points,
 *                  feasiblePoints(i,j) = 1 if (i,j) sample
 *                  should be in one mask of M, 0 otherwise
 * pdfType        = 0  for Gaussian, 
 *                  1  for Exponential, 
 *                  2  for uniform, 
 *                  3+ for polynomial with order pdfType - 3.0
 * R              = reduction factor for each phase: [Ry Rz]
 * opt            = Method for min. dist. relaxation: 
 *                  1- k-space and time, 0- k-space only
 * shapeOpt       = min. dist. criterion, shape generated by a sample
 * isPeriodicInK  = 1 for periodic k-space boundary conditions
 * isPeriodicInT  = 1 to periodize samples in time
 * dtScaling      = dt will be scaled by this amount (default = 1.0)
 *  
 * M              = [ny nz nt] sampling pattern. sum(M,3)
 *                  should be equal to feasiblePoints
 *
 *
 * References:
 *
 *
 * Evan Levine
 * egl@stanford.edu
 % Stanford University
 * 12/9/2013
 *
 * This is a MEX-file for MATLAB.
 *=======================================================*/
void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] )
{
    unsigned long j;
    if(nrhs != 10 ){ /* Check the number of arguments */
        mexPrintf("provided %d args\n", nrhs);
        mexErrMsgTxt("Wrong number of input arguments.");
    }else if(nlhs > 1){
        mexErrMsgTxt("Too many output arguments.");
    }

    long dims[DIMS];
    dims[T_DIM] = mxGetScalar(prhs[0]);
    const double FOVRatio = mxGetScalar(prhs[1]);
    const mxArray *feasiblePointsArr = prhs[2];
    const double *feasiblePoints = mxGetPr(feasiblePointsArr);
    const double pdfType = mxGetScalar(prhs[3]);
    const mxArray *RyRzArr = prhs[4];
    const double *RyRz = mxGetPr(RyRzArr);
    const double Ry = RyRz[0];
    const double Rz = RyRz[1];
    const double alphasq = Ry/Rz*pow(1/FOVRatio,2);
    const int distRelaxationOpt = mxGetScalar(prhs[5]);
    const int shapeOpt = mxGetScalar(prhs[6]);
    const int isPeriodicInK = mxGetScalar(prhs[7]);
    const int isPeriodicInT = mxGetScalar(prhs[8]);
    const double dtScaling = mxGetScalar(prhs[9]);

    const int *size = mxGetDimensions(feasiblePointsArr);
    dims[Y_DIM] = size[0];
    dims[Z_DIM] = size[1];
    mwSize dimsMw[3];
    dimsMw[0] = dims[Y_DIM];
    dimsMw[1] = dims[Z_DIM];
    dimsMw[2] = dims[T_DIM];

    struct dataStr *data = init_data_str(dims, isPeriodicInK, isPeriodicInT);
    
    if( arrIsZero(data->nptsK, feasiblePoints) ){
        mexErrMsgTxt("No feasible points\n");
    }

    mxArray *outArr;
    if( (outArr = mxCreateNumericArray( 3, dimsMw, mxDOUBLE_CLASS, mxREAL )) == NULL){
        mexErrMsgTxt("Failed to allocate output\n");
        return;
    }
    double *out = (double *) mxGetPr(outArr);
    
    mexPrintf("------------ Variable Density CPD -------------\nPDF: ");
    
    /* PDF */
    double *pdf = (double *) xmalloc(data->nptsKT*sizeof(double));
    switch( (int) pdfType ){
        case GAUSSIAN:
        {
            /* Gaussian */
            mexPrintf("Gaussian");
            const double sigmasq[2] = { pow(0.5f*(double)dims[Y_DIM],2), pow(0.5f*(double)dims[Z_DIM],2)};
            genGaussian3DPDF(pdf, dims, alphasq, sigmasq); 
            break;
        }
        case EXPONENTIAL:
        {
            /* Exponential */
            mexPrintf("Exponential");
            const double krT = 0.5f*(double)MAX(dims[Y_DIM], dims[Z_DIM]);
            genExponential3DPDF(pdf, dims, alphasq, krT);
            break;
        }
        case UNIFORM:
        {
            /* Uniform */
            mexPrintf("Uniform");
            genUniform3DPDF(pdf, dims);
            break;
        }
        default:
        {
            /* Polynomial */
            const double order = pdfType - 3;
            mexPrintf("Polynomial (order %.2f)", order);
            genPolynomial3DPDF(pdf, dims, alphasq, order);
            break;
        }
    }
    
    
    mexPrintf("\nMin. distance criterion: ");
    switch( shapeOpt ){
        case CROSS:
        {
            mexPrintf("cross");
            break;
        }
        case ELLIPSOID:
        {
            mexPrintf("ellipsoid");
            break;
        }
        case L1_BALL:
        {
            mexPrintf("l1 ball");
            break;
        }
        case CONES:
        {
            mexPrintf("cones");
            break;
        }
        default:
        {
            mexErrMsgTxt("Unrecognized min. distance criterion");
        }
    }
    
    mexPrintf("\nRy = %.2f, Rz = %.2f, FOVz/FOVy = %.2f", Ry, Rz, FOVRatio);
    if( isPeriodicInK ){
        mexPrintf("\nPeriodic k-space boundary conditions");
    }
    if( isPeriodicInT ){
        mexPrintf("\nPeriodizing samples in time");
    }
    mexPrintf("\nDims: %d %d %d", dims[Y_DIM], dims[Z_DIM], dims[T_DIM]);
    mexPrintf("\n-----------------------------------------------");

    /* Set up constraints */
    mexPrintf("\nInitializing constraints...");
    /* max samples = ny*nz*nt / Single phase reduction factor
     *             = nt * samples in each phase
     */
    long maxTotalSamples = (long) ((double) data->nptsKT / (Ry*Rz));
    long maxSamplesPerPhase = (maxTotalSamples + dims[T_DIM] - 1)/dims[T_DIM];

    struct samplingConstraints *constraints = initConstraints(maxSamplesPerPhase, maxTotalSamples, feasiblePoints);
    constraints->dist = initDst(data->dims, shapeOpt, distRelaxationOpt, sqrt(alphasq));
    calcMinKDistance(constraints->dist->dky, pdf, Ry*Rz, data->dims, 5.0f, feasiblePoints);
    calcMinTDistance(constraints->dist->dt, pdf, maxTotalSamples, data->dims, dtScaling, feasiblePoints);

    /* Generate the sampling pattern */
    const int periodizeSamples = 1;
    genVDCPD(data, pdf, constraints, periodizeSamples);
    for( j = 0 ; j < data->nptsKT ; j++ ){
        out[j] = (data->masks[j] == 1) ? 1 : 0;
    }
    plhs[0] = outArr;

    cleanup:    
    free(constraints->dist);
    free(constraints);
    free(pdf);
    free(data->masks);
    free(data->numSamplest);
    free(data);
    /*
    */
    
}
